// 第5章 代理模式
//代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问  代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身
//对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。
// 6.2 保护代理和虚拟代理
//  代理 B 可以帮助 A过滤掉一些请求 请求就可以直接在代理 B处被拒绝掉。这种代理叫作保护代理
// 虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。
// 保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式
// 6.3 虚拟代理实现图片预加载
// 在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个 img 标签节点设置 src 属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张
//loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到 img 节点里，这种场景就很适合使用虚拟代理。

// 6.4 代理的意义
// 为了说明代理的意义，下面我们引入一个面向对象设计的原则——单一职责原则
/**
 * 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可
能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能
会遭到意外的破坏。
职责被定义为“引起变化的原因”。上段代码中的 MyImage 对象除了负责给 img 节点设置 src
外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职
责的实现。
实际上，我们需要的只是给 img 节点设置 src，预加载图片只是一个锦上添花的功能。如果
能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出
来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体 MyImage。
纵观整个程序，我们并没有改变或者增加 MyImage 的接口，但是通过代理对象，实际上给系
统添加了新的行为。这是符合开放—封闭原则的。给 img 节点设置 src 和图片预加载这两个功能，
被隔离在两个对象里，它们可以各自变化而不影响对方。何况就算有一天我们不再需要预加载，
那么只需要改成请求本体而不是请求代理对象即可。
 */
// 6.5 代理和本体接口的一致性
/**
 * 上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请
求本体。其中关键是代理对象和本体都对外提供了 setSrc 方法，在客户看来，代理对象和本体
是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这
样做有两个好处
 用户可以放心地请求代理，他只关心是否能得到想要的结果。
 在任何使用本体的地方都可以替换成使用代理。
在 JavaScript 这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了
setSrc 方法，另外大多数时候甚至干脆不做检测，全部依赖程序员的自觉性，这对于程序的健壮
性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我
们也习惯了没有接口的世界。
 */
//6.6 虚拟代理合并 HTTP 请求
//6.7 虚拟代理在惰性加载中的应用
//6.8 缓存代理  缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。

var mut = function () {
  var a = 1;
  for (var i = 0, l = arguments.length; i < l; i++) {
    a = a * arguments[i];
  }
  return a;
};
this.pp = "发放";
var mulProxy = (function () {
  var cache = {};
  this.name = "prox";
  return function () {
    //这个返回方法中的this和外部的this是一个
    var args = Array.prototype.join.call(arguments, ",");
    if (args in cache) {
      return cache[args];
    }
    this.kk = "dada";
    // 直接用mut()和用mut.apply是不一样的，apply后面的第二个参数是一个数组，可直接传给mut作为参数，如果不用apply,直接传arguments，则arguments作为一个 参数数组的[]第一个参数{'0',arguments}
    return (cache[args] = mut.apply(this,arguments));
  };
})();
// console.log('大图标222',this)
let vv = mulProxy(3, 2, 3, 4);
console.log(vv);
